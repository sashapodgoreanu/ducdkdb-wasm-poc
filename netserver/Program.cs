
using netserver.Domain;

using Apache.Arrow;
using Apache.Arrow.Ipc;
using Apache.Arrow.Types;
using Apache.Arrow.Memory;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient<ParquetJsonService>();
builder.Services.AddTransient<ArrowFileReaderService>();

var app = builder.Build();

app.UseRouting();

// Endpoint to read Parquet files and return JSON
app.MapGet("/api/json_temp/{filename}/{limit?}", async (string filename, int? limit, ParquetJsonService parquetJsonService) =>
{
  try
  {
    var jsonLikeData = await parquetJsonService.GetDataAsync(filename, limit);
    return Results.Json(jsonLikeData);
  }
  catch (Exception ex)
  {
    return Results.Problem($"Error reading Parquet file: {ex.Message}");
  }
});

app.MapGet("/api/arrow/sample", async (HttpResponse response, CancellationToken cancellationToken) =>
{
  response.ContentType = "application/vnd.apache.arrow.stream";

  var recordBatch = CreateSampleRecordBatch();

  using var writer = new ArrowStreamWriter(response.Body, recordBatch.Schema);

  await writer.WriteRecordBatchAsync(recordBatch, cancellationToken);
  await writer.WriteEndAsync(cancellationToken);
});

// Endpoint to read the Arrow file
app.MapGet("/api/arrow/{filename}/{limit?}", async (string filename, int? limit, HttpResponse response, ArrowFileReaderService arrowFileReaderService) =>
{

  string arrowFilePath = Path.Combine(Directory.GetCurrentDirectory(), "static_files", "random.arrows");
  // string arrowFilePath = "random.arrows"; // Path to the Arrow file generated by the Python script

  // Set response content type for Arrow IPC stream
  response.ContentType = "application/vnd.apache.arrow.stream";

  // Read the Arrow file
  using var fileStream = arrowFileReaderService.ReadFileAsync(filename);
  using var reader = new ArrowStreamReader(fileStream);
  using var writer = new ArrowStreamWriter(response.Body, reader.Schema);

  int rowsWritten = 0; // Track the number of rows written
  RecordBatch batch;

  // Write batches until the limit is reached or all batches are processed
  while ((batch = reader.ReadNextRecordBatch()) != null)
  {
    if (limit.HasValue)
    {
      // If the current batch exceeds the remaining limit, slice it
      int rowsRemaining = limit.Value - rowsWritten;
      if (rowsRemaining <= 0) break;

      if (rowsRemaining < batch.Length)
      {
        // Slice the batch to the remaining rows
        batch = batch.Slice(0, rowsRemaining);
      }
    }

    // Write the (possibly sliced) batch
    await writer.WriteRecordBatchAsync(batch);
    rowsWritten += batch.Length;

    // Stop if the limit is reached
    if (limit.HasValue && rowsWritten >= limit.Value) break;
  }

  await writer.WriteEndAsync();
});

app.MapGet("/api/files/{filename}", async (HttpContext context, string filename) =>
{
  // Path to the file
  string filePath = Path.Combine(Directory.GetCurrentDirectory(), "static_files", filename);

  if (!System.IO.File.Exists(filePath))
  {
    context.Response.StatusCode = StatusCodes.Status404NotFound;
    await context.Response.WriteAsync("File not found.");
    return;
  }

  var fileInfo = new FileInfo(filePath);
  var fileLength = fileInfo.Length;
  var contentType = "application/octet-stream"; // Adjust MIME type as needed

  string rangeHeader = context.Request.Headers["Range"];
  if (string.IsNullOrEmpty(rangeHeader))
  {
    // No Range header present, return the entire file
    context.Response.Headers["Content-Length"] = fileLength.ToString();
    context.Response.Headers["Accept-Ranges"] = "bytes";
    context.Response.ContentType = contentType;

    await context.Response.SendFileAsync(filePath);
    return;
  }

  // Parse the Range header (e.g., "bytes=0-999")
  if (!rangeHeader.StartsWith("bytes=", StringComparison.OrdinalIgnoreCase))
  {
    context.Response.StatusCode = StatusCodes.Status416RequestedRangeNotSatisfiable;
    return;
  }

  var range = rangeHeader["bytes=".Length..].Split('-');
  if (range.Length != 2 ||
      !long.TryParse(range[0], out long rangeStart) ||
      (range[1].Length > 0 && !long.TryParse(range[1], out _)))
  {
    context.Response.StatusCode = StatusCodes.Status416RequestedRangeNotSatisfiable;
    return;
  }

  long rangeEnd = range.Length > 1 && range[1].Length > 0 ? long.Parse(range[1]) : fileLength - 1;

  if (rangeStart < 0 || rangeEnd >= fileLength || rangeStart > rangeEnd)
  {
    context.Response.StatusCode = StatusCodes.Status416RequestedRangeNotSatisfiable;
    return;
  }

  // Set response headers for partial content
  context.Response.StatusCode = StatusCodes.Status206PartialContent;
  context.Response.Headers["Content-Range"] = $"bytes {rangeStart}-{rangeEnd}/{fileLength}";
  context.Response.Headers["Content-Length"] = (rangeEnd - rangeStart + 1).ToString();
  context.Response.Headers["Accept-Ranges"] = "bytes";
  context.Response.ContentType = contentType;

  // Write the requested range to the response
  using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
  fileStream.Seek(rangeStart, SeekOrigin.Begin);

  // Create a buffer to copy the exact range
  var bufferSize = (int)(rangeEnd - rangeStart + 1);
  var buffer = new byte[bufferSize];
  await fileStream.ReadAsync(buffer, 0, bufferSize);
  await context.Response.Body.WriteAsync(buffer, 0, bufferSize);
});



static RecordBatch CreateSampleRecordBatch()
{
  // Define the schema
  var schema = new Schema.Builder()
      .Field(f => f.Name("id").DataType(Int32Type.Default).Nullable(false))
      .Field(f => f.Name("name").DataType(StringType.Default).Nullable(false))
      .Build();

  // Create the data arrays
  var idArray = new Int32Array.Builder()
      .Append(1).Append(2).Append(3).Append(4).Append(5)
      .Append(6).Append(7).Append(8).Append(9).Append(10)
      .Build();

  var nameArray = new StringArray.Builder()
      .Append("Alice").Append("Bob").Append("Charlie").Append("Diana")
      .Append("Eve").Append("Frank").Append("Grace").Append("Hank")
      .Append("Ivy").Append("Jack")
      .Build();

  // Create the record batch
  return new RecordBatch(
      schema,
      new IArrowArray[] { idArray, nameArray },
      idArray.Length // Number of rows
  );
}

app.Run();
