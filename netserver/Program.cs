
using netserver.Domain;

using Apache.Arrow;
using Apache.Arrow.Ipc;
using Apache.Arrow.Types;
using Apache.Arrow.Memory;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient<ParquetJsonService>();
builder.Services.AddTransient<ArrowFileReaderService>();

var app = builder.Build();

app.UseRouting();

// Endpoint to read Parquet files and return JSON
app.MapGet("/api/json_temp/{filename}/{limit?}", async (string filename, int? limit, ParquetJsonService parquetJsonService) =>
{
  try
  {
    var jsonLikeData = await parquetJsonService.GetDataAsync(filename, limit);
    return Results.Json(jsonLikeData);
  }
  catch (Exception ex)
  {
    return Results.Problem($"Error reading Parquet file: {ex.Message}");
  }
});

app.MapGet("/api/arrow/sample", async (HttpResponse response, CancellationToken cancellationToken) =>
{
  response.ContentType = "application/vnd.apache.arrow.stream";

  var recordBatch = CreateSampleRecordBatch();

  using var writer = new ArrowStreamWriter(response.Body, recordBatch.Schema);

  await writer.WriteRecordBatchAsync(recordBatch, cancellationToken);
  await writer.WriteEndAsync(cancellationToken);
});

// Endpoint to read the Arrow file
app.MapGet("/api/arrow/{filename}/{limit?}", async (string filename, int? limit, HttpResponse response, ArrowFileReaderService arrowFileReaderService) =>
{

  string arrowFilePath = Path.Combine(Directory.GetCurrentDirectory(), "static_files", "random.arrows");
  // string arrowFilePath = "random.arrows"; // Path to the Arrow file generated by the Python script

  // Set response content type for Arrow IPC stream
  response.ContentType = "application/vnd.apache.arrow.stream";

  // Read the Arrow file
  using var fileStream = arrowFileReaderService.ReadFileAsync(filename);
  using var reader = new ArrowStreamReader(fileStream);
  using var writer = new ArrowStreamWriter(response.Body, reader.Schema);

  int rowsWritten = 0; // Track the number of rows written
  RecordBatch batch;

  // Write batches until the limit is reached or all batches are processed
  while ((batch = reader.ReadNextRecordBatch()) != null)
  {
    if (limit.HasValue)
    {
      // If the current batch exceeds the remaining limit, slice it
      int rowsRemaining = limit.Value - rowsWritten;
      if (rowsRemaining <= 0) break;

      if (rowsRemaining < batch.Length)
      {
        // Slice the batch to the remaining rows
        batch = batch.Slice(0, rowsRemaining);
      }
    }

    // Write the (possibly sliced) batch
    await writer.WriteRecordBatchAsync(batch);
    rowsWritten += batch.Length;

    // Stop if the limit is reached
    if (limit.HasValue && rowsWritten >= limit.Value) break;
  }

  await writer.WriteEndAsync();
});

app.MapGet("/api/files/{filename}", (string filename) =>
{
  // Path to the Parquet file
  string parquetFilePath = Path.Combine(Directory.GetCurrentDirectory(), "static_files", filename);

  // Open a stream to the file and return it as a FileStreamResult
  var fileStream = new FileStream(parquetFilePath, FileMode.Open, FileAccess.Read);
  var contentType = "application/octet-stream"; // Use appropriate MIME type if known
  var fileDownloadName = filename; // Name for the downloaded file

  return Results.File(fileStream, contentType, fileDownloadName);
});


static RecordBatch CreateSampleRecordBatch()
{
  // Define the schema
  var schema = new Schema.Builder()
      .Field(f => f.Name("id").DataType(Int32Type.Default).Nullable(false))
      .Field(f => f.Name("name").DataType(StringType.Default).Nullable(false))
      .Build();

  // Create the data arrays
  var idArray = new Int32Array.Builder()
      .Append(1).Append(2).Append(3).Append(4).Append(5)
      .Append(6).Append(7).Append(8).Append(9).Append(10)
      .Build();

  var nameArray = new StringArray.Builder()
      .Append("Alice").Append("Bob").Append("Charlie").Append("Diana")
      .Append("Eve").Append("Frank").Append("Grace").Append("Hank")
      .Append("Ivy").Append("Jack")
      .Build();

  // Create the record batch
  return new RecordBatch(
      schema,
      new IArrowArray[] { idArray, nameArray },
      idArray.Length // Number of rows
  );
}

app.Run();
