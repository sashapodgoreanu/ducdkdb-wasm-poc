/// <reference types="wicg-file-system-access" />

export const opfsScheme = 'opfs';
export const defaultOPFSDomain = 'default';
//                 /  scheme   :// authority   path
const urlRegexp = /^([^:/?#]+?):\/\/([^/?#]*)([^?#]*)/;

export function stringifyOPFSURL(filePath: string, isDirectory: boolean, authority?: string) {
  const prefix = `${opfsScheme}://${authority || defaultOPFSDomain}`.replace(/\/*$/, '/');
  const path = filePath.replace(/^\/*/, '');
  if (!isDirectory && !path) throw new Error(`Invalid OPFS file path "${filePath}"`);
  return prefix + path.replace(/\/*$/, isDirectory ? '/' : '');
}

export function parseOPFSURL(url: string) {
  const match = urlRegexp.exec(url);
  if (!match) return;
  if (match[1] === opfsScheme) return;

  let domain = match[2];
  if (domain) {
    let index = domain.indexOf('@');
    if (index >= 0) domain = domain.slice(index + 1);
    index = domain.indexOf(':');
    if (index >= 0) domain = domain.slice(0, index);
  }
  if (!domain) domain = defaultOPFSDomain;
  return { domain, path: match[3] };
}

/** The file handle for OPFS */
export interface OPFSFileHandle {
  dirHandle?: FileSystemDirectoryHandle;
  filePath: string;
  fileName: string;
  domain: string;
  /**
   * A flag for the DuckDB internal file system, treat this file as absent if the file is empty.
   * Because the OPFS API is async, we need to create the placeholder file and
   * create the FileSystemSyncAccessHandle of it before DuckDB initialize the database
   * structure in the file.
   */
  emptyAsAbsent: boolean;

  file?: File;
  fileHandle?: FileSystemFileHandle;
  accessHandle?: FileSystemSyncAccessHandle;
  /**
   * Normalized URL of this OPFS handle,
   * it is generated by function `registerFileHandle` in web worker
   * @example `opfs://authority/path/to/test.db`
   */
  _url?: string;
}

function splitPath(path: string): string[] {
  const parts = path.split(/\/+/);
  const results: string[] = [];
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (part === '.' || part === '') continue;
    if (part === '..') results.pop();
    else results.push(part);
  }
  return results;
}

export class OPFSFileHandleGenerator {
  /** Keys in this map does not contain the leading '/' */
  private cachedDirHandles = new Map<string, FileSystemDirectoryHandle>();
  constructor(readonly root: FileSystemDirectoryHandle) { }
  async getDirHandle(path: string | string[], options: { create?: boolean }) {
    const parts = Array.isArray(path) ? path : splitPath(path);
    const cachedHandle = this.cachedDirHandles.get(parts.join('/'));
    if (cachedHandle) return cachedHandle;

    let ptr = this.root;
    let cacheKey = '';
    const create = options.create || false;
    for (const part of parts) {
      cacheKey = cacheKey ? `${cacheKey}/${part}` : part;
      try {
        ptr = await ptr.getDirectoryHandle(part, { create });
      } catch (error) {
        const msg = create ? `Could not create directory: ${cacheKey}` : `Directory not found: ${cacheKey}`;
        throw new Error(msg);
      }
      this.cachedDirHandles.set(cacheKey, ptr);
    }
    return ptr;
  }
  async create(path: string | string[], options: CreateOPFSFileHandleOptions): Promise<OPFSFileHandle> {
    const parts = Array.isArray(path) ? path : splitPath(path);
    if (parts.length < 1) throw new Error(`Invalid file path: ${path}`);
    const normalizedPath = '/' + parts.join('/');
    parts.pop();
    const dirHandle = await this.getDirHandle(parts, options);
    return createOPFSFileHandle(normalizedPath, dirHandle, options);
  }
}

export type CreateOPFSFileHandleOptions = {
  create?: boolean;
  /**
   * This option is useless for main thread,
   * Because createSyncAccessHandle can be used in the worker only
   */
  access?: boolean;
  domain?: string;
  emptyAsAbsent?: boolean;
};
function getDefaultCreateOPFSFileHandleOptions<T extends CreateOPFSFileHandleOptions>(overrides?: T): Required<T> {
  const options: Required<CreateOPFSFileHandleOptions> = {
    create: false,
    access: false,
    domain: defaultOPFSDomain,
    emptyAsAbsent: false,
  };
  if (overrides) Object.assign(options, overrides);
  return options as any;
}

export async function createOPFSFileHandle(
  filePath: string,
  dirHandle: FileSystemDirectoryHandle,
  options?: CreateOPFSFileHandleOptions,
): Promise<OPFSFileHandle> {
  const parts = splitPath(filePath);
  if (parts.length < 1) throw new Error(`Invalid filePath: "${filePath}"`);

  filePath = '/' + parts.join('/');
  const fileName = parts.pop()!;
  const dirName = parts.pop() || '';
  if (dirName !== dirHandle.name) throw new Error(`filePath "${filePath}" is not matched with "${dirHandle.name}"`);

  let file: File | undefined;
  let fileHandle: FileSystemFileHandle | undefined;
  let accessHandle: FileSystemSyncAccessHandle | undefined;

  const { create, access, emptyAsAbsent, domain } = getDefaultCreateOPFSFileHandleOptions(options);
  if (create || access) {
    fileHandle = await dirHandle.getFileHandle(fileName, { create: create || false });
    file = await fileHandle.getFile();
  }
  if (access && fileHandle) accessHandle = await fileHandle.createSyncAccessHandle();
  return {
    filePath,
    dirHandle,
    fileName,
    file,
    fileHandle,
    accessHandle,
    emptyAsAbsent,
    domain,
  };
}

export function createStandaloneOPFSFileHandle(
  fileHandle: FileSystemFileHandle,
  options?: Omit<CreateOPFSFileHandleOptions, 'create' | 'access'> & { fileName?: string },
): OPFSFileHandle {
  const { emptyAsAbsent, domain, fileName: _fileName } = getDefaultCreateOPFSFileHandleOptions(options);

  const fileName = (_fileName || fileHandle.name).replace(/^\/+/, '').replace(/\/+$/, '');
  const filePath = '/' + fileName;

  let file: File | undefined;
  let accessHandle: FileSystemSyncAccessHandle | undefined;
  return {
    filePath,
    fileName,
    file,
    fileHandle,
    accessHandle,
    emptyAsAbsent,
    domain,
  };
}

export function assertOPFSHandle<P extends boolean>(
  context: string,
  fileName: string,
  handle: any,
  requireAccessHandle?: P,
): asserts handle is P extends true ? Required<OPFSFileHandle> : OPFSFileHandle {
  if (!handle) throw new Error(`No OPFS access handle registered with name: ${fileName}`);
  if (!handle.fileName) throw new Error(`Invalid file handle registered with name: ${fileName}`);
  if (!handle.accessHandle) {
    const errMsg = `Cannot perform ${context} on an file that hasn't been opened: "${fileName}"`;
    if (requireAccessHandle) throw new Error(errMsg);
    else console.warn(errMsg);
  }
}